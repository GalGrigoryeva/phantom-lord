# @funboxteam/phantom-lord

## Описание библиотеки

**phantom-lord** — это библиотека, предоставляющая удобный интерфейс для взаимодействия с [Headless Chromium](https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md), вдохновлённая [CasperJS](http://casperjs.org/).

Библиотека может использоваться для автоматизированного тестирования, создания обходчиков сайтов и других задач, требующих наличия виртуального браузера.

## Преимущества библиотеки

В качестве виртуального браузера используется Headless Chromium, благодаря чему страница, открытая в виртуальном браузере, будет иметь тот же вид, что и в обычном Chrome с графическим интерфейсом. Кроме того, всегда используется только актуальная версия Chromium, в отличие от PhantomJS, поддержка и развитие которого прекращены.

Для управления браузером используется библиотека [Puppeteer](https://developers.google.com/web/tools/puppeteer/). В отличие от CasperJS и PhantomJS, все управляющие инструкции выполняются в контексте Node.js, что позволяет использовать ES2015 и более новые стандарты, а также библиотеки, написанные для Node.js.

Любознательный пользователь может заметить, что уже есть библиотека, позволяющая писать тесты на Node.js и выполнять их в виртуальном браузере, и называется она [Selenium](http://www.seleniumhq.org/). К сожалению, библиотека Selenium написана на языке программирования Java, а работа с виртуальным браузером не всегда бывает гладкой, поэтому в случае возникновения проблем для отладки требуется знание трех языков программирования и соответствующих инфраструктур (Node.js, Java, C++), что приводит к большим затратам времени и специфическим требованиям к компетенции разработчика. Стремление решить эту проблему стало одной из мотиваций написания библиотеки.

## Особенности работы с библиотекой

### Каталог проекта

Для определения корневого каталога проекта в **phantom-lord** используется [app-root-path](https://www.npmjs.com/package/app-root-path). В частности, в корневом каталоге создается подкаталог `screenshots`.
Ввиду [особенностей app-root-path](https://www.npmjs.com/package/app-root-path#primary-method), не стоит размещать свой проект в каталоге с названием `node_modules` или его подкаталогах.

* Правильно: `~/work/my-project/`
* Неправильно: `~/work/node_modules/my-project/`

### Создание экземпляра браузера

Чтобы приступить к работе с браузером, подключите библиотеку в проект и создайте экземпляр класса `Browser`:

```
const Browser = require('@funboxteam/phantom-lord');
const browser = new Browser();
```

### Команды

Список доступных команд находится в файле [lib/commands/index.js](./lib/commands/index.js).

### Использование команд и порядок их выполнения

Работа с библиотекой чаще всего представляет из себя выполнение нескольких последовательных шагов. Например: открыть страницу, дождаться появления надписи, нажать на кнопку. Указанные шаги должны выполняться друг за другом, несмотря на то, что каждый из них может быть асинхронным. При этом крайне желательно создать видимость синхронного кода для удобства чтения тестов. Для осуществления этой задачи используется механизм `async/await`.

Таким образом, добиться последовательного выполнения всех стандартных функций, таких как `open`, `click`, `waitForUrl`, можно, используя вышеуказанные выражения.
Каждая команда, объявленная с оператором `await`, ожидает завершения выполнения. В случае успешного ответа о выполнении происходит переход к следующей команде. Если какая-то команда завершилась с ошибкой, то дальнейшие шаги не выполняются.

В таком примере:

```javascript
await browser.open('https://yandex.ru');
await browser.waitForText('Найти');
await browser.sendKeys('.form__field', 'hello');
```

сначала выполнится команда `open`, потом `waitForText`, а потом `sendKeys`. Если какая-нибудь команда вернула ошибку, то следующие за ней выполняться не будут.

Асинхронные действия *всегда* должны возвращать Promise. В случае успешного завершения шага должен вызваться метод `resolve`, в случае ошибки — `reject`. При этом вызов асинхронного кода (функции) должен предваряться оператором `await`.

Например:

```javascript
function doSmthAsync() {
  return new Promise((resolve, reject) => {
    // выполняем какие-то асинхронные действия
    resolve();
  });
};

await doSmthAsync();
```

В случае ошибки нужно передать в `reject` объект ошибки `new Error(data)`, где `data` — содержимое ошибки.

Например:

```javascript
doSmthAsync () {
  return new Promise((resolve, reject) => {
    // выполняем какие-то асинхронные действия
    reject(new Error('описание ошибки'));
  });
};

await doSmthAsync();
```

Нестандартные для библиотеки команды можно писать непосредственно в том месте, где предполагается их выполнение. Это возможно благодаря использованию `await`, т.к. интерпретатор не перейдет к следующей команде, пока не будет получен результат от предыдущей.

Например:

```javascript
await browser.open('https://ya.ru');
console.log('страница открыта');
await browser.waitForText('Найти');
```

### События

Объект `browser` может генерировать ряд событий:

* `error` — возникла ошибка в процессе выполнения шага;
* `timeout` — возник timeout в процессе выполнения шага;
* `phantomError` — возникла ошибка при отправке команды в связанный процесс Chromium (обычно это говорит о том, что процесс вскоре аварийно завершится);
* `browserErrors` — возникли JS-ошибки на странице;
* `exit` — связанный процесс Chromium завершился;

Подписаться на обработку событий можно следующим образом:

```javascript
browser.on('error', (e) => {
  console.log(`Произошла ошибка ${e}`);
});
```

### Состояния

В процессе работы объект `browser` может находиться в одном из нескольких состояний:

* `notStarted` — связанный процесс Chromium не запущен;
* `starting` — связанный процесс Chromium запускается;
* `started` — связанный процесс Chromium запущен и готов к работе (или работает);
* `error` — в процессе выполнения очередного шага произошла ошибка при отправке команды в связанный процесс Chromium, требуется завершение работы;
* `exiting` — происходит завершение связанного процесса Chromium.

Получить текущее состояние можно с помощью обращения к свойству `state`:

```javascript
console.log(`Текущее состояние: ${browser.state}`);
```

### Переменные окружения

* `DEBUG` (boolean) — вывод отладочных сообщений (сообщения об отправленных командах, полученных ответах, сообщения из консоли запущенного браузера и так далее);
* `BROWSER_ARGS` — JSON с аргументами запуска виртуального браузера. Может содержать следующие параметры:
    * `viewportWidth` — ширина окна браузера в числовом формате (например, 1200);
    * `viewportHeight` — высота окна браузера в числовом формате (например, 900);
    * `waitTimeout` — время в миллисекундах, по истечению которого проверка в команде ожидания будет считаться проваленной;
    * `slowMo` — данный параметр замедляет выполнение всех действий внутри браузера на указанное количество миллисекунд. Отличие от переменной `E2E_TESTS_WITH_PAUSES` в том, что `slowMo` влияет на выполнение всех действий по взаимодействию с браузером (в том числе клики, переходы, ввод данных и так далее), в то время как `E2E_TESTS_WITH_PAUSES` влияет на интервал между действиями по ожиданию чего-либо.
* `E2E_TESTS_WITH_PAUSES` (boolean) — установка дополнительной задержки между проверками в командах ожидания (`waitForUrl`, `waitForText` и так далее); данный режим позволяет обнаружить нестабильные ошибки, связанные со слишком быстрым выполнением проверок.
* `HEADLESS_OFF` (boolean) — отключение headless-режима браузера при выполнении команд. Браузер открывается в привычном оконном режиме и позволяет не только визуально наблюдать за процессом выполнения, но и при необходимости вмешиваться в него. Может быть полезно при отладке.

### Стабы

При использовании библиотеки достаточно частой задачей является добавление стабов на страницу, поэтому в рамках библиотеки добавлена частичная поддержка решения данной задачи.

Для добавления стабов предлагается использовать функцию `addStubToQueue`. Данная функция добавляет указанные стабы в переменную `window.stubs` на страницу.

Также функция `addStubToQueue` позволяет передать стабы в браузер еще до загрузки страницы. В этом случае данные сохранятся в процессе phantom-lord и будут добавлены в переменную `window.stubs` сразу, как только страница будет загружена.

Формат добавляемых стабов зависит от реализации на клиенте и не определяется библиотекой. Единственное, о чем нужно помнить — передаваемые в браузер данные сериализуются, следовательно, нельзя ссылаться на данные внутри процесса Node.js.

### localStorage

Каждый запуск браузера происходит с новым чистым профилем пользователя, для которого создается уникальная директория. При добавлении в браузере данных в localStorage, данные хранятся в созданной директории. После закрытия браузера эта директория удаляется автоматически.

## Использование библиотеки

Подключение библиотеки:

```javascript
const Browser = require('@funboxteam/phantom-lord');
```

Запуск браузера и настройка вывода ошибок:

```javascript
const browser = new Browser();
browser.on('timeout', () => console.log('browser timeout!'));
browser.on('error', () => console.log('browser error!'));
await browser.startRemoteBrowser();
```

Команда `browser.startRemoteBrowser()` вызывается автоматически во время выполнения `browser.open()`, если в этот момент времени браузер еще не запущен. При попытке выполнить команду, взаимодействующую со страницей, до непосредственного открытия браузера, будет возвращена ошибка `notStarted`. В этом случае нужно либо вручную вызвать `browser.startRemoteBrowser()` (будет открыта пустая страница about:blank), либо вызвать `browser.open()` с необходимым адресом в качестве аргумента.

Исполнение команд:

```javascript
await browser.open('https://ya.ru');
await browser.waitForText('Найти');
await browser.sendKeys('.form__field', 'hello');
await browser.click('button');
await browser.waitForUrl('yandex.ru');
await browser.waitForText('показов в месяц');
```

Так как библиотека решает только задачу взаимодействия с Headless Chrome, то для написания e2e-тестов необходимо подключить дополнительные инструменты, например, [Mocha.js](https://mochajs.org/).

Простейший код с использованием данного тестового фреймворка будет выглядеть так:

```javascript
const Browser = require('@funboxteam/phantom-lord');
let browser;
let restartReason;
let test;

describe('Проверка yandex.ru', function() {
  // Здесь не стрелочная функция, чтобы Mocha.js могла подменить контекст this.
  beforeEach(async function() {
    test = this.currentTest;

    browser = new Browser();

    browser.on('timeout', (e) => {
      console.log('e2e-tests timeout!');
      test.callback(e); // в случае таймаута завершаем тест с ошибкой
    });

    browser.on('error', (e) => {
      console.log('e2e-tests error!');
      test.callback(new Error(e)); // в случае ошибки при выполнении шага завершаем тест с ошибкой
    });

    // В случае, если в браузере возникла ошибка, завершаем тест.
    // Для некоторых систем наличие ошибок в браузере — нормальная ситуация, но для большинства — нет.
    browser.on('browserErrors', (e) => {
      console.log('Ошибка браузера, тест провален');
      test.callback(new Error(e[0].msg));
    });

    // Обработка внутренней ошибки funbox-phantom-lord (падение Chromium).
    browser.on('phantomError', (e) => {
      if (browser.testAlreadyFailed) {
        console.log('Ошибка Chromium внутри afterEach, тест не перезапускаем');
      } else {
        console.log('Ошибка Chromium, перезапуск теста');
        test.currentRetry(0);
        test.retries(1);
        restartReason = 'phantomError';
        test.callback(new Error(e || 'Error'));
      }
    });

    // Обработка закрытия Chromium.
    browser.on('exit', (code, signal) => {
      if (browser.state === 'started' || browser.state === 'starting') {
        console.log(`Chromium внезапно завершился code '${code}' signal '${signal}', перезапуск теста`);
        test.currentRetry(0);
        test.retries(1);
        restartReason = 'exit';
        test.callback(new Error('Unexpected Chromium exit'));
      }
    });
    
    // после добавления всех обработчиков запускаем браузер
    await browser.startRemoteBrowser();
  });

  afterEach(function() {
    const exit = () => browser.exit();

    // Если тест завершился с ошибкой, делаем скриншот для удобства разбора падения.
    if (this.currentTest.state === 'failed') {
      // Если падение теста произошло по вине падения Chromium, то пытаться сделать скриншот бесполезно.
      if (browser.state !== 'started') {
        console.log(`Не делаем скриншот, потому что browser.state = ${browser.state}`);
        return undefined;
      }
      let t = this.currentTest;
      const p = [];
      while (t) {
        p.unshift(t.title);
        t = t.parent;
      }

      const pad = (x) => (x < 10 ? '0' : '') + x;
      const time = new Date(parseInt(process.env.E2E_TESTS_START_TIMESTAMP, 10));
      p.unshift(`${time.getFullYear()}_${pad((time.getMonth() + 1))}_${pad(time.getDate())}_${pad(time.getHours())}_${pad(time.getMinutes())}_${pad(time.getSeconds())}`);

      p.unshift('screenshots');
      const fname = `${p.join('/')}.png`;
      browser.testAlreadyFailed = true;

      // Не важно, как завершилась команда получения скриншота, после нее нужно в любом случае завершить работу браузера, иначе останется зомби-процесс.
      return browser.capture(fname).then(exit, exit);
    }

    return exit();
  });

  it('тест поиска', async () => {
    await browser.open('https://ya.ru');
    await browser.waitForText('Найти');
    await browser.sendKeys('.input__control', 'hello');
    await browser.click('button');
    await browser.waitForUrl('yandex.ru');
    await browser.waitForText('показов в месяц'); // если мы не дождемся данной надписи, тест провалится
  });
});
```
## Совместимость с предыдущими версиями библиотеки

### Содержимое страницы

Предыдущие версии библиотеки для запуска виртуального браузера использовали PhantomJS, который имеет плохую поддержку современных web-технологий и свой взгляд на содержимое страницы. В связи с этим, при переходе на тесты с использованием Headless Chrome могут возникать некоторые различия в том, как браузеры "видят" контент.

Пример: браузер, запускаемый в PhantomJS, может проигнорировать неразрывный пробел между словами, и для `17&nbsp;640` ожидаемый текст будет «17640». Chromium же сохранит этот пробел, и для него ожидаемый текст будет «17 640».

**Важно**: если в текстовом содержимом элемента содержатся символы неразрывного пробела (`&nbsp;`), они будут заменены на обычные пробелы при получении текста элемента (например, при использовании метода `waitForSelectorText`). В случае, если тест упал на проверке текста с похожей ошибкой

```
Error: Expected text of '.dialog__content p' to be 'Вы уверены, что хотите отключить услугу?', but it was 'Вы уверены, что хотите отключить услугу?'
```
скорее всего это значит, что текст для теста был скопирован напрямую со страницы с сохранением неразрывных пробелов. В этом случае нужно удалить в проверяемом тексте пробелы и заново добавить их вручную.

### Обработка кликов по элементам документа

Механика обработки событий мыши (в первую очередь, кликов) различна для PhantomJS и Headless Chrome. Так, в PhantomJS используется способ создания нового события `Event` c последующим вызовом этого события на конкретном элементе с помощью `EventTarget.dispatchEvent()`. В Headless Chrome определяется положение искомого элемента на странице, затем клик производится по найденным координатам.

Если команда на клик успешно проходит, но далее не происходит ничего, что ожидается после клика, есть вероятность, что клик проходит по нужным координатам, но попадает на другой элемент. Возможный пример такого случая: наличие модальных окон или "прелоадеров", которые блокируют контент. Если на странице есть прелоадер и команда на клик посылается сразу после открытия страницы, стоит добавить отдельную команду, которая подождет исчезновения этого прелоадера.

Особое внимание следует обратить на клик по элементам, которые являются "невидимыми". PhantomJS и Headless Chrome смогут кликнуть по элементу, даже если его размеры 0х0. Однако, если для элемента или его родителя задано CSS-свойство `display: none`, то в Headless Chrome попытка клика по такому элементу вернет ошибку `invisibleElement`, поскольку параметры его блочной модели и положение невозможно определить.

В случае ошибки, связанной с кликом по невидимому элементу, убедитесь, что ни элемент, ни один из его родителей, не имеют стилей, полностью скрывающих их на странице. В противном случае, перед кликом необходимо задать действие, возвращающее невидимый элемент в документ. Это может быть, к примеру, наведение на какой-то элемент (с использованием `browser.hover`) или клик по другому элементу.

### Очистка localStorage

Поскольку предыдущие версии библиотеки были основаны на использовании PhantomJS, уникальный путь к localStorage создавался средствами самой библиотеки funbox-phantom-lord и требовал ручной очистки с помощью вызова `Browser.deleteLocalStorageBaseDir();`.

В новой версии вызов данной функции более не требуется.

### Прочие проблемы совместимости

Если в процессе переноса тестов с прошлых версий библиотеки на версию с использованием Headless Chromium вы столкнулись с какими-либо другими неотмеченными проблемами перехода, связанными с отличиями в отображении страницы между PhantomJS и Headless Chromium, поставьте задачу в FD на дополнение данного раздела в документации.
