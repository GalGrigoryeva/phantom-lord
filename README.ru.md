# frontend-e2e-tests-env

Библиотека, предоставляющая удобный интерфейс для взаимодействия с phantomjs, вдохновлённая casperjs.

## Использование

Подключить к тесту:

```javascript
const Browser = require('frontend-e2e-tests-env');
```

Запустить сервер и настроить вывод ошибок:

```javascript
this.browser = new Browser();
this.browser.on('timeout', () => console.log('browser timeout!'));
this.browser.on('error', () => console.log('browser error!'));
```

Использовать:

```javascript
this.browser.open('https://ya.ru');
this.browser.waitForText('Найти');
this.browser.sendKeys('.input__input', 'hello');
this.browser.click('button');
this.browser.waitForUrl('yandex.ru');
this.browser.waitForText('показов в месяц');
```

## Шаги

Работа с библиотекой чаще всего представляет из себя выполнение нескольких последовательных шагов. Например, открыть страницу, дождаться появления надписи, нажать на кнопку. Указанные шаги должны выполняться друг за другом, несмотря на то, что каждый из них может быть асинхронным. Данное поведение достигается за счет того, что запрошенные действия выполняются не сразу, а сначала добавляются в очередь. Каждый асинхронный шаг возвращает Promise, за счет чего библиотека может определить когда закончился предыдущий шаг, чтобы перейти к следующему. Все стандартные функции, такие как open, click, waitForUrl, waitForText инкапсулируют в себя логику добавления очередного шага в очередь, поэтому ничего дополнительно делать не нужно.

В таком примере:

```javascript
browser.open('https://ya.ru');
browser.waitForText('Найти');
browser.sendKeys('.input__input', 'hello');
```

сначала выполнится команда open, потом waitForText, а потом sendKeys. Если какая-нибудь команда вернула ошибку - то следующие за ней выполняться не будут.

Если в цепочку шагов нужно вклинить какие-то нестандартные для библиотеки команды - то их необходимо обернуть в конструкцию `browser.then`, например:

```javascript
browser.open('https://ya.ru');
browser.then(() => {
  console.log('страница открыта');
});
browser.waitForText('Найти');
```

В случае, если этого не сделать, то строка "страница открыта" будет напечатана еще до открытия страницы. Это связано с тем, что `browser.open` дословно означает - поставить в очередь команду на открытие страницы, а `console.log` - напечатать строку прямо сейчас (без постановки в очередь). Каждый шаг может быть синхронным и асинхронным. Синхронный шаг в случае успеха возвращает какой-то результат (или не возвращает - что тоже является успешным завершением шага), а в случае ошибки генерирует исключение. Например:

```javascript
browser.then(() => {
  throw new Error('Ошибка');
});
```

Асинхронные шаги *всегда* должны возвращать Promise. В случае успешного завершения шага должен вызваться метод resolve, в случае ошибки - reject. Например:

```javascript
browser.then(() => {
  return new Promise((resolve, reject) => {
    // выполняем какие-то асинхронные действия
    resolve();
  });
});
```

При этом есть возможность в функции resolve передать некоторый результат на вход следующему шагу, например:

```javascript
browser.then(() => {
  return new Promise((resolve, reject) => {
    // передаем строку 'hello world' на вход следующему шагу
    resolve('hello world');
  });
});

browser.then((str) => {
  console.log(str); // будет напечатано сообщение "hello world"
});
```

В случае ошибки нужно передать в reject объект, содержащий 2 свойства: type - тип ошибки (может быть error или timeout) и data - содержимое ошибки. Например:

```javascript
browser.then(() => {
  return new Promise((resolve, reject) => {
    reject({type: 'error', data: 'описание ошибки'});
  });
});
```

Если какой-то шаг завершился с ошибкой - дальнейшие шаги не выполняются.

Прежде чем начать обработку очереди шагов библиотека запускает связанный процесс PhantomJS.

## События

Объект `browser` может генерировать ряд событий:

* error - возникла ошибка в процессе выполнения шага
* timeout - возник timeout в процессе выполнения шага
* phantomError - возникла ошибка в процессе отправки команды в связанных PhantomJS процесс (обычно это говорит о том, что связанный процесс вскоре аварийно завершится)
* exit - связанный процесс PhantomJS завершился
* stepsFinished - шаги в очереди закончились

Подписаться на обработку событий можно следующим образом

```javascript
browser.on('error', (e) => {
  console.log(`Произошла ошибка ${e}`);
});
```

## Состояния

В процессе работы объект `browser` может находиться в одном из нескольких состояний:

* notStarted - связанный процесс PhantomJS не запущен
* starting - связанный процесс PhantomJS запускается
* started - связанный процесс PhantomJS запущен и готов к работе (или работает)
* error - в процессе выполнения очередного шага произошла ошибка при отправке команды в связанный процесс PhantomJS, требуется завершение работы
* exiting - происходит завершение связанного процесса PhantomJS

## Общие команды

TBD
