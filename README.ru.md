# funbox-phantom-lord

## Описание библиотеки

**funbox-phantom-lord** — это библиотека, предоставляющая удобный интерфейс для взаимодействия с [PhantomJS](http://phantomjs.org/), вдохновлённая [CasperJS](http://casperjs.org/).

Библиотека может использоваться для автоматизированного тестирования, создания обходчиков сайтов и других задач, требующих наличия виртуального браузера.

## Преимущества библиотеки

Выделение управляющей логики в отдельный процесс позволяет минимизировать ущерб от падений PhantomJS, а также перезапускать PhantomJS настолько часто, насколько это необходимо.

В отличие от CasperJS, управляющие инструкции выполняются в контексте Node.js, а не PhantomJS, что позволяет использовать ES2015 и более новые стандарты, а также библиотеки, написанные для Node.js.

Любознательный пользователь может заметить, что уже есть библиотека, позволяющая писать тесты на Node.js и выполнять их в виртуальном браузере, и называется она [Selenium](http://www.seleniumhq.org/). К сожалению, библиотека Selenium написана на языке программирования Java, а работа с виртуальным браузером не всегда бывает гладкой, поэтому в случае возникновения проблем для отладки требуется знание трех языков программирования и соответствующих инфраструктур (Node.js, Java, C++), что приводит к большим затратам времени и специфическим требованиям к компетенции разработчика. Стремление решить эту проблему стало одной из мотиваций написания библиотеки.

## Особенности работы с библиотекой

### Порты

**Важно!** Библиотека использует порты `10100-10200` для запуска PhantomJS, поэтому данные порты должны быть свободны в системе.

### Webpack

**Важно!** При работе с React-проектами параметр [`devtool`](https://webpack.js.org/configuration/devtool/) конфигурации `webpack` должен быть установлен либо пустой строкой (`''`) либо значением `'source-map'`.

При значении по умолчанию и при других значениях PhantomJS падает с внутренней ошибкой.

### Команды

Список доступных команд находится в файле [index.js](./index.js).

### Шаги

Работа с библиотекой чаще всего представляет из себя выполнение нескольких последовательных шагов. Например: открыть страницу, дождаться появления надписи, нажать на кнопку. Указанные шаги должны выполняться друг за другом, несмотря на то, что каждый из них может быть асинхронным. При этом крайне желательно создать видимость синхронного кода для удобства чтения тестов. Данное поведение достигается за счет того, что запрошенные действия выполняются не сразу, а сначала добавляются в очередь. Каждый асинхронный шаг возвращает Promise, за счет чего библиотека может определить, когда закончился предыдущий шаг, чтобы перейти к следующему. Если какой-то шаг завершился с ошибкой, то дальнейшие шаги не выполняются.

Прежде чем начать обработку очереди шагов, библиотека запускает связанный процесс PhantomJS. Все стандартные функции, такие как `open`, `click`, `waitForUrl`, `waitForText` инкапсулируют в себя логику добавления очередного шага в очередь, поэтому ничего дополнительно делать не нужно.

В таком примере:

```javascript
browser.open('https://ya.ru');
browser.waitForText('Найти');
browser.sendKeys('.form__field', 'hello');
```

сначала выполнится команда `open`, потом `waitForText`, а потом `sendKeys`. Если какая-нибудь команда вернула ошибку, то следующие за ней выполняться не будут.

Каждый шаг может быть синхронным и асинхронным. Синхронный шаг в случае успеха возвращает какой-то результат (или не возвращает, что тоже является успешным завершением шага), а в случае ошибки — генерирует исключение.

Например:

```javascript
browser.then(() => {
  throw new Error('Ошибка');
});
```

Асинхронные шаги *всегда* должны возвращать Promise. В случае успешного завершения шага должен вызваться метод `resolve`, в случае ошибки — `reject`.

Например:

```javascript
browser.then(() => {
  return new Promise((resolve, reject) => {
    // выполняем какие-то асинхронные действия
    resolve();
  });
});
```

При этом есть возможность в функции `resolve` передать некоторый результат на вход следующему шагу, например:

```javascript
browser.then(() => {
  return new Promise((resolve, reject) => {
    // передаем строку 'hello world' на вход следующему шагу
    resolve('hello world');
  });
});

browser.then((str) => {
  console.log(str); // будет напечатано сообщение «hello world»
});
```

В случае ошибки нужно передать в `reject` объект, содержащий два свойства: `type` — тип ошибки (может быть `error` или `timeout`) и `data` — содержимое ошибки.

Например:

```javascript
browser.then(() => {
  return new Promise((resolve, reject) => {
    reject({type: 'error', data: 'описание ошибки'});
  });
});
```

Если в цепочку шагов нужно вклинить какие-то нестандартные для библиотеки команды, то их необходимо обернуть в конструкцию `browser.then`.

Например:

```javascript
browser.open('https://ya.ru');
browser.then(() => {
  console.log('страница открыта');
});
browser.waitForText('Найти');
```

В случае, если этого не сделать, строка «страница открыта» будет напечатана еще до открытия страницы. Это связано с тем, что `browser.open` дословно означает «поставить в очередь команду на открытие страницы», а `console.log` — «напечатать строку прямо сейчас» (без постановки в очередь).

### События

Объект `browser` может генерировать ряд событий:

* `error` — возникла ошибка в процессе выполнения шага;
* `timeout` — возник timeout в процессе выполнения шага;
* `phantomError` — возникла ошибка при отправке команды в связанный процесс PhantomJS (обычно это говорит о том, что процесс вскоре аварийно завершится);
* `browserErrors` — возникли JS-ошибки на странице;
* `exit` — связанный процесс PhantomJS завершился;
* `stepsFinished` — шаги в очереди закончились.

Подписаться на обработку событий можно следующим образом:

```javascript
browser.on('error', (e) => {
  console.log(`Произошла ошибка ${e}`);
});
```

### Состояния

В процессе работы объект `browser` может находиться в одном из нескольких состояний:

* `notStarted` — связанный процесс PhantomJS не запущен;
* `starting` — связанный процесс PhantomJS запускается;
* `started` — связанный процесс PhantomJS запущен и готов к работе (или работает);
* `error` — в процессе выполнения очередного шага произошла ошибка при отправке команды в связанный процесс PhantomJS, требуется завершение работы;
* `exiting` — происходит завершение связанного процесса PhantomJS.

Получить текущее состояние можно с помощью обращения к свойству `state`:

```javascript
console.log(`Текущее состояние: ${browser.state}`);
```

### Переменные окружения

* `PHANTOM_OUTPUT` — вывод отладочных сообщений от процесса PhantomJS (сообщения об ошибках в браузере, принятых командах и так далее);
* `DEBUG` — вывод отладочных сообщений из процесса основного Node.js (сообщения об отправленных командах, полученных ответах и так далее);
* `BROWSER_ARGS` — аргументы запуска процесса PhantomJS (ширина и высота страницы, кэш и так далее, подробнее можно узнать в [документации к PhantomJS](http://phantomjs.org/api/command-line.html));
* `E2E_TESTS_WITH_PAUSES` — установка дополнительной задержки между проверками в командах ожидания (`waitForUrl`, `waitForText` и так далее); данный режим позволяет обнаружить нестабильные ошибки, связанные со слишком быстрым выполнением проверок.

### Стабы

При использовании библиотеки достаточно частой задачей является добавление стабов на страницу, поэтому в рамках библиотеки добавлена частичная поддержка решения данной задачи.

Для добавления стабов предлагается использовать функцию `addStubToQueue`. Данная функция добавляет указанные стабы в переменную `window.stubs` на страницу.

Также функция `addStubToQueue` позволяет передать стабы в браузер еще до загрузки страницы. В этом случае данные сохранятся в процессе PhantomJS и будут добавлены в переменную `window.stubs` сразу, как только страница будет загружена.

Формат добавляемых стабов зависит от реализации на клиенте и не определяется библиотекой. Единственное, о чем нужно помнить — передаваемые в браузер данные сериализуются, следовательно, нельзя ссылаться на данные внутри процесса Node.js.

### localStorage

С целью устранения связи между тестами для каждого процесса PhantomJS указывается уникальный путь к localStorage в папке `node_modules/.funbox-phantom-lord-local-storage` проекта. Желательно перед запуском тестов удалить эту папку, чтобы она не разрасталась и не занимала место на диске:

```
const Browser = require('funbox-phantom-lord');
Browser.deleteLocalStorageBaseDir();
```

## Использование библиотеки

Подключение библиотеки:

```javascript
const Browser = require('funbox-phantom-lord');
```

Запуск сервера и настройка вывода ошибок:

```javascript
browser = new Browser();
browser.on('timeout', () => console.log('browser timeout!'));
browser.on('error', () => console.log('browser error!'));
```

Исполнение команд:

```javascript
browser.open('https://ya.ru');
browser.waitForText('Найти');
browser.sendKeys('.form__field', 'hello');
browser.click('button');
browser.waitForUrl('yandex.ru');
browser.waitForText('показов в месяц');
```

Так как библиотека решает только задачу взаимодействия с PhantomJS, то для написания e2e-тестов необходимо подключить дополнительные инструменты, например, [Mocha.js](https://mochajs.org/).

Простейший код с использованием данного тестового фреймворка будет выглядеть так:

```javascript
let browser;
let restartReason;
let test;

describe('Проверка yandex.ru', function() {
  // Здесь не стрелочная функция, чтобы Mocha.js могла подменить контекст this.
  beforeEach(function() {
    test = this.currentTest;
    test.async = true; // помечаем тест как асинхронный

    browser = new Browser();

    browser.on('timeout', (e) => {
      console.log('e2e-tests timeout!');
      test.callback(e); // в случае таймаута завершаем тест с ошибкой
    });

    browser.on('error', (e) => {
      console.log('e2e-tests error!');
      test.callback(new Error(e)); // в случае ошибки при выполнении шага завершаем тест с ошибкой
    });

    // Код отслеживания текущей ситуации с шагами.
    let stepsFinishedProcessed = false;
    browser.on('stepsFinished', () => {
      // Данная проверка нужна, чтобы исключить повторное событие завершения шагов.
      // Например, когда при падении теста делается скриншот, который тоже является командой, приводящей к генерации события завершения шагов.
      if (!stepsFinishedProcessed) {
        stepsFinishedProcessed = true;
        // Если все шаги завершились и не произошло никаких ошибок, значит, тест завершился успешно.
        if (test.state !== 'failed') test.callback();
      }
    });

    // В случае, если в браузере возникла ошибка, завершаем тест.
    // Для некоторых систем наличие ошибок в браузере — нормальная ситуация, но для большинства — нет.
    browser.on('browserErrors', (e) => {
      console.log('Ошибка браузера, тест провален');
      test.callback(new Error(e[0].msg));
    });

    // Обработка ошибки PhantomJS.
    browser.on('phantomError', (e) => {
      if (browser.testAlreadyFailed) {
        console.log('Ошибка PhantomJS внутри afterEach, тест не перезапускаем');
      } else {
        console.log('Ошибка PhantomJS, перезапуск теста');
        test.currentRetry(0);
        test.retries(1);
        restartReason = 'phantomError';
        test.callback(new Error(e || 'Error'));
      }
    });

    // Обработка падения PhantomJS.
    browser.on('exit', (code, signal) => {
      if (browser.state === 'started' || browser.state === 'starting') {
        console.log(`PhantomJS внезапно завершился code '${code}' signal '${signal}', перезапуск теста`);
        test.currentRetry(0);
        test.retries(1);
        restartReason = 'exit';
        test.callback(new Error('Unexpected PhantomJS exit'));
      }
    });
  });

  afterEach(function() {
    const exit = () => browser.exit();

    // Если тест завершился с ошибкой, делаем скриншот для удобства разбора падения.
    if (this.currentTest.state === 'failed') {
      // Если падение теста произошло по вине падения PhantomJS, то пытаться сделать скриншот бесполезно.
      if (browser.state !== 'started') {
        console.log(`Не делаем скриншот, потому что browser.state = ${browser.state}`);
        return undefined;
      }
      let t = this.currentTest;
      const p = [];
      while (t) {
        p.unshift(t.title);
        t = t.parent;
      }

      const pad = (x) => (x < 10 ? '0' : '') + x;
      const time = new Date(parseInt(process.env.E2E_TESTS_START_TIMESTAMP, 10));
      p.unshift(`${time.getFullYear()}_${pad((time.getMonth() + 1))}_${pad(time.getDate())}_${pad(time.getHours())}_${pad(time.getMinutes())}_${pad(time.getSeconds())}`);

      p.unshift('screenshots');
      const fname = `${p.join('/')}.png`;
      browser.testAlreadyFailed = true;

      // Не важно, как завершилась команда получения скриншота, после нее нужно в любом случае завершить работу браузера, иначе останется зомби-процесс.
      return browser.capture(fname).then(exit, exit);
    }

    return exit();
  });

  it('тест поиска', () => {
    browser.open('https://ya.ru');
    browser.waitForText('Найти');
    browser.sendKeys('.form__field', 'hello');
    browser.click('button');
    browser.waitForUrl('yandex.ru');
    browser.waitForText('показов в месяц'); // если мы не дождемся данной надписи, тест провалится
  });
});
```
